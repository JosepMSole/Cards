<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DECK 6-5</title>

<style>
:root{
  --cardW:175px;
  --cardH:246px;
  --headerH:90px;
  --hudDur:.5s;
}
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  background:#070b18;
  font-family:system-ui;
  color:white;
}
header{
  position:fixed;
  top:0;left:0;right:0;
  height:var(--headerH);
  background:black;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:12px;
  z-index:1000;
}
header button{
  padding:10px 14px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.2);
  background:rgba(255,255,255,.08);
  color:white;
  font-weight:800;
  cursor:pointer;
  user-select:none;
}
header button.active{
  background:rgba(124,92,255,.4);
  box-shadow:0 0 18px rgba(124,92,255,.35);
}
#total{
  padding:10px 14px;
  border-radius:14px;
  background:rgba(255,255,255,.1);
  border:1px solid rgba(255,255,255,.2);
  font-weight:900;
}
#total .num{ font-size:1.35em; font-weight:1000; margin-left:6px; }

/* ===== v3-5 HEADER FX ===== */
header{
  position:fixed;
  top:0;left:0;right:0;
  height:var(--headerH);
  background:
    radial-gradient(1200px 120px at 50% 0%, rgba(124,92,255,.22), transparent 70%),
    linear-gradient(180deg, rgba(0,0,0,.92), rgba(0,0,0,.78));
  border-bottom:1px solid rgba(255,255,255,.10);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  overflow:hidden;
}
header::before{
  content:"";
  position:absolute;
  inset:-40px -60px;
  background:
    repeating-linear-gradient(
      180deg,
      rgba(255,255,255,.045) 0px,
      rgba(255,255,255,.045) 1px,
      transparent 2px,
      transparent 6px
    );
  opacity:.25;
  mix-blend-mode:overlay;
  pointer-events:none;
  animation:scanMove 4.5s linear infinite;
}
header::after{
  content:"";
  position:absolute;
  inset:0;
  background: radial-gradient(600px 90px at 50% 10%, rgba(45,212,191,.10), transparent 65%);
  opacity:.8;
  pointer-events:none;
}
@keyframes scanMove{
  0%{ transform:translateY(0); }
  100%{ transform:translateY(46px); }
}

header button.hdrBtn{
  position:relative;
  padding:10px 14px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.18);
  background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
  color:white;
  font-weight:900;
  cursor:pointer;
  user-select:none;
  display:flex;
  align-items:center;
  gap:10px;
  letter-spacing:.4px;
  text-shadow:0 1px 0 rgba(0,0,0,.55);
  transform:translateZ(0);
  transition:
    transform .12s ease,
    box-shadow .18s ease,
    border-color .18s ease,
    filter .18s ease;
  isolation:isolate;
}
header button.hdrBtn .ico{
  font-size:18px;
  line-height:1;
  filter:drop-shadow(0 0 10px rgba(124,92,255,.25));
}
header button.hdrBtn::before{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius:16px;
  background:
    radial-gradient(160px 36px at 20% 0%, rgba(45,212,191,.22), transparent 60%),
    radial-gradient(180px 42px at 80% 100%, rgba(124,92,255,.18), transparent 60%);
  opacity:.0;
  transition:opacity .18s ease;
  pointer-events:none;
  z-index:-1;
}
header button.hdrBtn::after{
  content:"";
  position:absolute;
  inset:0;
  border-radius:14px;
  background:linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
  transform:translateX(-140%);
  opacity:.0;
  pointer-events:none;
  mix-blend-mode:screen;
}
header button.hdrBtn:hover{
  transform:translateY(-1px);
  border-color:rgba(124,92,255,.35);
  box-shadow:0 0 0 1px rgba(124,92,255,.10), 0 0 26px rgba(124,92,255,.22);
  filter:saturate(1.15) brightness(1.05);
}
header button.hdrBtn:hover::before{ opacity:1; }
header button.hdrBtn:hover::after{
  opacity:.55;
  animation:btnSheen .7s ease;
}
@keyframes btnSheen{
  0%{ transform:translateX(-140%); }
  100%{ transform:translateX(140%); }
}
header button.hdrBtn:active{
  transform:translateY(0px) scale(.985);
  filter:brightness(1.08);
}

/* Glitch pulse (applied via JS occasionally) */
header button.hdrBtn.glitch{
  animation:glitchJolt .24s steps(2,end) 1;
}
header button.hdrBtn.glitch .lbl{
  position:relative;
}
header button.hdrBtn.glitch .lbl::before,
header button.hdrBtn.glitch .lbl::after{
  content:attr(data-txt);
  position:absolute;
  left:0; top:0;
  opacity:.65;
  pointer-events:none;
}
header button.hdrBtn.glitch .lbl::before{
  transform:translate(1px,-1px);
  color:rgba(45,212,191,.9);
  clip-path:inset(0 0 55% 0);
}
header button.hdrBtn.glitch .lbl::after{
  transform:translate(-1px,1px);
  color:rgba(255,80,120,.9);
  clip-path:inset(55% 0 0 0);
}
@keyframes glitchJolt{
  0%{ transform:translateY(-1px) skewX(0deg); }
  50%{ transform:translateY(-1px) skewX(6deg); }
  100%{ transform:translateY(-1px) skewX(0deg); }
}

header button.active,
header button.hdrBtn.active{
  background:rgba(124,92,255,.40);
  box-shadow:0 0 18px rgba(124,92,255,.35);
  border-color:rgba(124,92,255,.45);
}
/* ===== end v3-5 header fx ===== */

#stage{
  position:fixed;
  inset:var(--headerH) 0 0 0;
  overflow:hidden;
  touch-action:none;
  cursor:grab;
  background:#070b18;
}

#world{
  position:absolute;
  inset:0;
  transform-origin:0 0;
  will-change:transform;
}
#stage.panning{ cursor:grabbing; }

#viewport{
  position:absolute;
  inset:0;
  transform-origin:0 0;
  will-change:transform;
  z-index:1;
}

#bg{
  position:absolute;
  left:0;
  top:0;
  width:100%;
  height:100%;
  transform-origin:0 0;
  will-change:transform;
  z-index:0;
  pointer-events:none;
  background:
    radial-gradient(1200px 800px at 40% 30%, rgba(124,92,255,.25), transparent 60%),
    radial-gradient(900px 600px at 70% 60%, rgba(255,202,58,.18), transparent 55%),
    url("images/bg.jpg") center/cover no-repeat;
}

/* CARD */
.piece{
  position:absolute;
  z-index:1;
  width:var(--cardW);
  height:var(--cardH);
  perspective:1200px;
  -webkit-perspective:1200px;
  transform-style:preserve-3d;
  -webkit-transform-style:preserve-3d;
  touch-action:none;
}

.card{
  position:absolute;
  inset:0;
  border-radius:18px;
  overflow:hidden;
  box-shadow:0 14px 40px rgba(0,0,0,.6);

  background: transparent;z-index:2;

  transform-style:preserve-3d;
  -webkit-transform-style:preserve-3d;
  will-change:transform;
}

/* Each face rotates, not the parent (more reliable across browsers). */
.face{
  position:absolute;
  inset:0;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;

  backface-visibility:hidden;
  -webkit-backface-visibility:hidden;

  transition:transform .45s cubic-bezier(.2,.7,.2,1);
  will-change:transform;

  /* micro translateZ helps avoid front "bleeding" through on some GPUs */
  transform:translateZ(0.5px);

  transform-style:preserve-3d;
  -webkit-transform-style:preserve-3d;

  image-rendering:auto;
}

.front{ transform:rotateY(0deg) translateZ(0.5px); }
.back { transform:rotateY(180deg) translateZ(0.5px); background-color:#111; }

.card.flipped .front{ transform:rotateY(-180deg) translateZ(0.5px); }
.card.flipped .back { transform:rotateY(0deg) translateZ(0.5px); }

/* Flip button: always top-right, regardless of face */
.flipBtn{
  position:absolute;
  top:8px; right:8px;
  width:40px;height:40px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.2);
  background:rgba(0,0,0,.4);
  color:white;
  font-weight:900;
  cursor:pointer;
  z-index:6;
  user-select:none;
}

/* HUD */
.hudAction,.hudInfo{
  position:absolute;
  border-radius:18px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(15,23,48,.95);
  box-shadow:0 12px 34px rgba(0,0,0,.6);
  opacity:0;
  transition:opacity var(--hudDur) ease, transform var(--hudDur) cubic-bezier(.2,.7,.2,1);
  pointer-events:auto;
  z-index:1;
}
.hudAction{
  width:140px;height:120px;
  left:-140px;
  top:calc((var(--cardH) - 120px)/2);
  display:flex;align-items:center;justify-content:center;
  transform:translateX(40px);
}
.hudInfo{
  min-width:200px;
  max-width:280px;
  left:var(--cardW);
  top:0;
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:10px;
  transform:translateX(-40px);
}
.piece.hudOpen .hudAction,
.piece.hudOpen .hudInfo{
  opacity:1;
  transform:translateX(0);
}
.irBtn{
  width:66px;height:66px;border-radius:18px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(45,212,191,.3);
  color:#fff;font-weight:1000;cursor:pointer;
}
.infoThumb{
  width:100%;
  aspect-ratio:16/9;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.10);
  background-color: rgba(255,255,255,.06);
}
.infoText{
  font-size:13px;
  white-space:pre-wrap;
  line-height:1.25;
}

/* Flash */
@keyframes wildFlash{
  0%{ filter:brightness(1) contrast(1); transform:scale(1); }
  20%{ filter:brightness(3) contrast(2.4) saturate(1.6); transform:scale(1.08) rotate(-3deg); }
  50%{ transform:scale(1.05) rotate(3deg); }
  100%{ filter:brightness(1) contrast(1); transform:scale(1); }
}
.piece.flash .card,
.piece.flash .hudAction,
.piece.flash .hudInfo{ animation:wildFlash .2s ease; }

/* Hide card shadow during flip to avoid static shadow plane */
.piece.flipping .card{ box-shadow:none !important; }

/* Selected glow (only on front-click) */
.piece.selected .card{
  box-shadow:
    0 14px 40px rgba(0,0,0,.6),
    0 0 0 2px rgba(124,92,255,.55),
    0 0 28px rgba(124,92,255,.55),
    0 0 58px rgba(124,92,255,.35);
}

/* ===== v4-1 MOBILE LAYOUT (only mobile) ===== */
@media (max-width: 768px){
  .infoText{font-size:10px;line-height:1.2;}

  :root{
    /* mobile: slightly larger cards (still many visible) */
    --cardW:78px;
    --cardH:110px;
    /* taller header + 2-row wrap */
    --headerH:124px;
  }
  header{
    padding:6px 10px 6px;
    justify-content:center;
    align-items:center;
    flex-wrap:wrap;
    column-gap:8px;
    row-gap:0px;
  }
  header button.hdrBtn{
    padding:8px 10px;
    border-radius:14px;
    font-size:12px;
    gap:8px;
  }
  header button.hdrBtn .ico{ font-size:16px; }
  #total{
    padding:8px 10px;
    border-radius:14px;
    font-size:12px;
    width:fit-content;
  }
  #total .num{font-size:1.85em;font-weight:900;}
  .flipBtn{
    width:28px;height:28px;
    border-radius:10px;
    top:6px; right:6px;
    font-size:14px;
  }
  .hudAction{
    width:92px;height:70px;
    left:-92px;
    top:calc((var(--cardH) - 70px)/2);
    transform:translateX(26px) scale(.82);
    transform-origin:center;
  }
  .irBtn{ width:40px;height:40px;border-radius:12px; }
  .hudInfo{
    left:var(--cardW);
    max-width:200px;
    padding:6px;
    max-height:calc(var(--cardH) - 10px);
    overflow:hidden;
    transform:translateX(-30px) scale(.55);
    transform-origin:left top;
  }  .piece.hudOpen .hudAction{ transform:translateX(0) scale(.82); }
  .piece.hudOpen .hudInfo{ transform:translateX(0) scale(.82); }

  /* v4-6 mobile fixes: INFO HUD shows image + text (no cropping) */
  .hudInfo{
    /* keep HUD smaller than the card height, but allow both thumb + text */
    max-height:calc(var(--cardH) - 8px);
    overflow:hidden;
    gap:6px;
  }
  .infoThumb{
    /* make the thumb smaller so description is always visible */
    aspect-ratio:auto;
    height:40px;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  .infoText{
    display:block;
    font-size:10px;
    line-height:1.2;
    overflow:hidden;
  }


  /* v5-1: encourage high-quality interpolation on mobile */
  #world{ transform:translate3d(0,0,0); }
  .face{
    -webkit-transform:translateZ(0.5px);
    transform:translateZ(0.5px);
    image-rendering:auto;
  }

  /* v4-6 mobile fix: avoid pixelation when zooming (iOS rasterization) */
  .card{ will-change:auto; }
  .face{ will-change:auto; transform-style:preserve-3d; -webkit-transform-style:preserve-3d; }
  .front{ transform:rotateY(0deg); }
  .back{ transform:rotateY(180deg); }
  .card.flipped .front{ transform:rotateY(-180deg); }
  .card.flipped .back{ transform:rotateY(0deg); }

}


@media (max-width: 768px){
  .hudAction{
    left:0 !important;
    top:-80px !important;
    transform:translateY(20px) scale(.9) !important;
  }
  .piece.hudOpen .hudAction{
    transform:translateY(0) scale(.9) !important;
  }
  .hudInfo{
    left:0 !important;
    top:var(--cardH) !important;
    transform:translateY(-20px) scale(.9) !important;
    transform-origin:top center !important;
  }
  .piece.hudOpen .hudInfo{
    transform:translateY(0) scale(.9) !important;
  }
}

/* ===== end v4-1 mobile ===== */


/* ===== FX OVERLAY (v5-1) ===== */
#fx{
  position:fixed;
  inset:0;
  pointer-events:none;
  overflow:hidden;
  isolation:isolate;
  z-index:20; /* above world, below header */
}
#fx canvas{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  display:block;
}
#shade{ mix-blend-mode:multiply; opacity:0.235; }
#lightMap{
  mix-blend-mode:screen;
  filter:blur(10px) brightness(1.55) saturate(1.10);;
  opacity:.25;
}
#dust{ mix-blend-mode:screen; opacity:0.2125; }
/* ===== end FX OVERLAY ===== */

@media (max-width: 768px){
  #fx{ display:none !important; }
}




/* ===== v6-4 MOBILE HEADER (reduce + 2 rows) ===== */
.miniCount{ display:none; padding:10px 14px; border-radius:14px; background:rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.2); font-weight:900; }
.miniCount .num{ font-size:1.35em; font-weight:1000; margin-left:6px; }

@media (max-width:768px){
  header{
    height:112px;
    padding:6px 10px 6px;
    justify-content:center;
    align-items:center;
    flex-wrap:wrap;
    column-gap:8px;
    row-gap:4px;
  }
  header button.hdrBtn{
    padding:7px 9px;
    border-radius:14px;
    font-size:12px;
    gap:8px;
  }
  #btnDeal, #btnFrame{ display:none !important; }
  #total, #leidasCount, #pendientesCount{ display:flex; align-items:center; }
  #total, #leidasCount, #pendientesCount{
    padding:7px 9px;
    border-radius:14px;
    font-size:12px;
    width:fit-content;
  }
  #total .num, #leidasCount .num, #pendientesCount .num{ font-size:1.55em; font-weight:900; }
}
/* ===== end v6-4 header ===== */


/* ===== v6-4 MOBILE BOARD (3 zones centered) ===== */
@media (max-width:768px){
  #mobileBoard{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    display:flex;
    align-items:center;
    justify-content:center;
    gap:22px;
    z-index:4;
    pointer-events:none;
  }
  #zoneRight{
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:28px;
  }
  .zoneWrap{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
  }
  .slot{
    width:calc(var(--cardW) * 1.10);
    height:calc(var(--cardH) * 1.60);
    border-radius:18px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(0,0,0,.10);
    box-shadow:0 10px 30px rgba(0,0,0,.25) inset;
  }
  .slotDeck{
    width:var(--cardW);
    height:calc(var(--cardH) * 2 + 18px);
    background:transparent;
    border:0;
    box-shadow:none;
  }

  .zoneLabel{
    padding:10px 18px;
    border-radius:18px;
    font-weight:1000;
    letter-spacing:.6px;
    border:2px solid rgba(255,255,255,.75);
    text-shadow:0 2px 0 rgba(0,0,0,.55);
    box-shadow:0 10px 28px rgba(0,0,0,.35);
    background:rgba(0,0,0,.35);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
  }
  .zoneLabelRead{
    background:linear-gradient(180deg, rgba(22,163,74,.85), rgba(22,163,74,.55));
    border-color:rgba(255,255,255,.85);
  }
  .zoneLabelPending{
    background:linear-gradient(180deg, rgba(220,38,38,.85), rgba(220,38,38,.55));
    border-color:rgba(255,255,255,.85);
  }
}
/* ===== end v6-4 board ===== */


/* ===== v6-4 MOBILE HUD alignment by zone ===== */
@media (max-width:768px){
  .piece.z1 .hudInfo{
    left:auto !important;
    right:var(--cardW) !important;
    transform-origin:top right !important;
  }
  .piece.zRead .hudInfo,
  .piece.zPending .hudInfo{
    left:var(--cardW) !important;
    right:auto !important;
    transform-origin:top left !important;
  }
}
/* ===== end v6-4 hud alignment ===== */


/* ===== v6-5 MOBILE: top-card preview + snap piles ===== */
@media (max-width:768px){
  /* counts as colored pills */
  #leidasCount{ background:rgba(22,163,74,.35) !important; border-color:rgba(22,163,74,.65) !important; }
  #pendientesCount{ background:rgba(220,38,38,.35) !important; border-color:rgba(220,38,38,.65) !important; }

  /* smoother drag */
  .piece{ will-change:transform; }
  .piece.lit .card{
    box-shadow:
      0 14px 40px rgba(0,0,0,.6),
      0 0 0 2px rgba(180,255,140,.55),
      0 0 40px rgba(120,255,90,.55),
      0 0 90px rgba(120,255,90,.35);
  }
}
/* ===== end v6-5 ===== */

</style>
</head>
<body>

<header>
<button id="btnDeck" class="hdrBtn"><span class="ico" aria-hidden="true">üÇ†</span><span class="lbl">MAZO</span></button>
<button id="btnDraw" class="hdrBtn"><span class="ico" aria-hidden="true">üé¥</span><span class="lbl">SACAR UNA</span></button>
<button id="btnDeal" class="hdrBtn"><span class="ico" aria-hidden="true">üÉè</span><span class="lbl">REPARTIR</span></button>
<button id="btnMove" class="hdrBtn"><span class="ico" aria-hidden="true">üåÄ</span><span class="lbl">MOVER</span></button>
<button id="btnFrame" class="hdrBtn"><span class="ico" aria-hidden="true">üéØ</span><span class="lbl">ENCUADRAR</span></button>
<div id="total">TOTAL: <span class="num">0</span></div>
<div id="leidasCount" class="miniCount">LE√çDAS: <span class="num">0</span></div>
<div id="pendientesCount" class="miniCount">PENDIENTES: <span class="num">0</span></div>
</header>

<div id="stage">
  <div id="world">
    <div id="bg"></div>

<div id="mobileBoard" aria-hidden="true">
  <div id="zone1Slot" class="slot slotDeck"></div>

  <div id="zoneRight">
    <div id="zoneReadWrap" class="zoneWrap">
      <div class="zoneLabel zoneLabelRead">LE√çDAS</div>
      <div id="zoneReadSlot" class="slot slotRead"></div>
    </div>

    <div id="zonePendingWrap" class="zoneWrap">
      <div id="zonePendingSlot" class="slot slotPending"></div>
      <div class="zoneLabel zoneLabelPending">PENDIENTES</div>
    </div>
  </div>
</div>

    <div id="viewport"></div>
  </div>
</div>


<div id="fx">
  <canvas id="shade"></canvas>
  <canvas id="lightMap"></canvas>
  <canvas id="dust"></canvas>
</div>

<script>
const viewport = document.getElementById("viewport");
const stage = document.getElementById("stage");
const world = document.getElementById("world");
const bg = document.getElementById("bg");
const totalEl = document.getElementById("total");

const btnDeck  = document.getElementById("btnDeck");
const btnDraw  = document.getElementById("btnDraw");
const btnDeal  = document.getElementById("btnDeal");
const btnMove  = document.getElementById("btnMove");
const btnFrame = document.getElementById("btnFrame");

const isMobile = window.matchMedia && window.matchMedia("(max-width: 768px)").matches;
/* ===== v6-4 mobile zones state ===== */
let mobileZone = new Map(); // piece -> "z1" | "read" | "pending"
let zRead = [];
let zPending = [];

function qs(id){ return document.getElementById(id); }

function getCardWH(){
  const cs = getComputedStyle(document.documentElement);
  return {
    w: parseFloat(cs.getPropertyValue("--cardW")) || 78,
    h: parseFloat(cs.getPropertyValue("--cardH")) || 110
  };
}

function boardRects(){
  const s = stage.getBoundingClientRect();
  const r1 = qs("zone1Slot")?.getBoundingClientRect();
  const rr = qs("zoneReadSlot")?.getBoundingClientRect();
  const rp = qs("zonePendingSlot")?.getBoundingClientRect();
  return {s, r1, rr, rp};
}

function pointInRect(x,y,r){
  return !!r && x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
}

function setZone(p, z){
  mobileZone.set(p, z);
  p.el.classList.toggle("z1", z==="z1");
  p.el.classList.toggle("zRead", z==="read");
  p.el.classList.toggle("zPending", z==="pending");
}

function syncCounts(){
  const le = document.getElementById("leidasCount");
  const pe = document.getElementById("pendientesCount");
  if(le) le.querySelector(".num").textContent = String(zRead.length);
  if(pe) pe.querySelector(".num").textContent = String(zPending.length);
}

function layoutMobileZones(){
  if(!isMobile) return;
  const {w,h} = getCardWH();
  const {s, r1, rr, rp} = boardRects();
  if(!r1 || !rr || !rp) return;

  const toWorld = (rect) => ({
    x: rect.left - s.left,
    y: rect.top  - s.top,
    w: rect.width,
    h: rect.height
  });
  const W1 = toWorld(r1);
  const WR = toWorld(rr);
  const WP = toWorld(rp);

  const z1x = W1.x + (W1.w - w)/2;
  const z1y = W1.y + (W1.h - h)/2;

  pieces.forEach((p)=>{
    const z = mobileZone.get(p) || "z1";
    if(z === "z1"){
      p.tx = z1x; p.baseTx = z1x;
      p.ty = z1y; p.baseTy = z1y;
    }
  });

  const stackIn = (arr, slot, baseTop=true) => {
    // pile: small offsets, like a deck
    const baseX = slot.x + (slot.w - w)/2;
    const baseY = slot.y + (slot.h - h)/2;
    const off = 6; // px offset between cards
    arr.forEach((p, i)=>{
      const dx = i * off;
      const dy = i * off * 0.55;
      p.tx = baseX + dx; p.baseTx = p.tx;
      p.ty = baseY + dy; p.baseTy = p.ty;
      p.el.style.zIndex = 200 + i; // above board
      p.ts = 1;
      p.el.classList.remove('lit');
    });
  };

  stackIn(zRead, WR, true);
  stackIn(zPending, WP, false);
  refreshDeckVisibility();
}

function dropToZone(p, clientX, clientY){
  if(!isMobile) return false;
  const {rr, rp} = boardRects();
  if(pointInRect(clientX, clientY, rr)){
    zPending = zPending.filter(x=>x!==p);
    if(!zRead.includes(p)) zRead.push(p);
    setZone(p, "read");
    syncCounts();
    layoutMobileZones();
    return true;
  }
  if(pointInRect(clientX, clientY, rp)){
    zRead = zRead.filter(x=>x!==p);
    if(!zPending.includes(p)) zPending.push(p);
    setZone(p, "pending");
    syncCounts();
    layoutMobileZones();
    return true;
  }
  return false;
}
/* ===== end v6-4 mobile zones state ===== */

/* ===== v6-5 mobile top-card (zone1 sequential) ===== */
function deckTop(){
  // top is the last piece in z1 by zIndex (highest)
  const z1 = pieces.filter(p => (mobileZone.get(p)||'z1')==='z1');
  if(!z1.length) return null;
  z1.sort((a,b)=> (parseInt(a.el.style.zIndex||0) - parseInt(b.el.style.zIndex||0)));
  return z1[z1.length-1];
}

function refreshDeckVisibility(){
  if(!isMobile) return;
  const top = deckTop();
  for(const p of pieces){
    const z = mobileZone.get(p)||'z1';
    if(z==='z1'){
      const isTop = (p===top);
      p.el.style.opacity = isTop ? "1" : "0";
      p.el.style.pointerEvents = isTop ? "auto" : "none";
    }else{
      p.el.style.opacity = "1";
      p.el.style.pointerEvents = "auto";
    }
  }
}
/* ===== end v6-5 ===== */


let maxScale = isMobile ? 1.0 : 2.5;

let pieces = [];
let selectedPiece = null;
let scale = 1, panX = 0, panY = 0;
let minScale = isMobile ? 1.0 : 1;          // allow more zoom-out on mobile
let homeScale = isMobile ? 1.0 : 1;

// BG overscan so it never reveals black margins, while still moving with zoom.
let bgBaseW = 0, bgBaseH = 0, bgOffX = 0, bgOffY = 0;
function updateBgMetrics(){
  const rect = stage.getBoundingClientRect();
  // Make BG large enough so that even at minScale it still covers the stage.
  const overscan = 1.06; // small safety margin
  bgBaseW = rect.width / Math.max(0.0001, minScale) * overscan;
  bgBaseH = rect.height / Math.max(0.0001, minScale) * overscan;

  // Center the BG around the stage at pan=0.
  bgOffX = -(bgBaseW - rect.width) / 2;
  bgOffY = -(bgBaseH - rect.height) / 2;

  bg.style.width = bgBaseW + "px";
  bg.style.height = bgBaseH + "px";
  bg.style.left = bgOffX + "px";
  bg.style.top = bgOffY + "px";
}
         // initial framing (closer than minScale)
let moverOn = false;
let zTop = 10;

function clampPan(){
  if(isMobile){ panX=0; panY=0; return; }

  // Clamp so the BG always covers the stage (no black margins).
  const rect = stage.getBoundingClientRect();
  const w = rect.width, h = rect.height;
  if(!bgBaseW || !bgBaseH) updateBgMetrics();

  const minTx = w - (bgOffX + bgBaseW) * scale;
  const maxTx = -bgOffX * scale;
  const minTy = h - (bgOffY + bgBaseH) * scale;
  const maxTy = -bgOffY * scale;

  panX = Math.min(maxTx, Math.max(minTx, panX));
  panY = Math.min(maxTy, Math.max(minTy, panY));
}

function updateView(){
  if(isMobile){ panX = 0; panY = 0; scale = 1; }

  clampPan();
  world.style.transform = `translate3d(${panX}px,${panY}px,0) scale(${scale})`;
}


function clearSelection(){
  if(selectedPiece){
    selectedPiece.el.classList.remove("selected");
    selectedPiece = null;
  }
}

function closeAllHUD(){
  pieces.forEach(p => p.el.classList.remove("hudOpen"));
}

/* CREATE CARD */
function createPiece(meta){
  const el = document.createElement("div");
  el.className = "piece";
  el.style.zIndex = ++zTop;

  const card = document.createElement("div");
  card.className = "card";

  const front = document.createElement("div");
  front.className = "face front";
  if(meta.front){
    const u = encodeURI("images/" + meta.front);
    front.style.backgroundImage = `url("${u}")`;
  }

  const back = document.createElement("div");
  back.className = "face back";
  if(meta.back){
    const u = encodeURI("images/" + meta.back);
    back.style.backgroundImage = `url("${u}")`;
  }

  // Flip button is duplicated: one on FRONT and one on BACK so it always sits top-right
  // and rotates with the visible face (no "plane staying still" during flip).
  const mkFlipBtn = () => {
    const b = document.createElement("button");
    b.className = "flipBtn";
    b.textContent = "‚Üª";
    b.addEventListener("pointerdown", e => { e.stopPropagation(); });
    b.addEventListener("click", e => { e.stopPropagation(); el.classList.add("flipping"); card.classList.toggle("flipped"); closeAllHUD(); setTimeout(()=>el.classList.remove("flipping"), 520); });
    return b;
  };
  front.appendChild(mkFlipBtn());
  back.appendChild(mkFlipBtn());

  card.append(front, back);

  const hudA = document.createElement("div");
  hudA.className = "hudAction";
  const ir = document.createElement("button");
  ir.className = "irBtn";
  ir.textContent = "IR";
  ir.addEventListener("pointerdown", e => e.stopPropagation());
  ir.addEventListener("click", e => {
    e.stopPropagation();
    if(meta.url) window.open(meta.url, "_blank", "noopener,noreferrer");
  });
  hudA.appendChild(ir);

  const hudI = document.createElement("div");
  hudI.className = "hudInfo";
  if(meta.hud){
    const thumb = document.createElement("div");
    thumb.className = "infoThumb";
    thumb.style.backgroundImage = `url("images/${meta.hud}")`;

    // v5-1: apply manifest crop if present (fill width, crop overflow, no deformation)
    const c = meta.hudCrop;
    if(c && typeof c === "object"){
      const sc = Number(c.scale || 1);
      const ox = Number(c.x || 0);
      const oy = Number(c.y || 0);
      thumb.style.backgroundSize = `${Math.max(0.1, sc) * 100}%`;
      thumb.style.backgroundPosition = `calc(50% + ${ox}px) calc(50% + ${oy}px)`;
      thumb.style.backgroundRepeat = "no-repeat";
    }else{
      // fallback: always fill the slot (cropped if needed)
      thumb.style.backgroundSize = "cover";
      thumb.style.backgroundPosition = "center";
      thumb.style.backgroundRepeat = "no-repeat";
    }

    hudI.appendChild(thumb);
  }
  if(meta.hudText){
    const text = document.createElement("div");
    text.className = "infoText";
    text.textContent = meta.hudText;
    hudI.appendChild(text);
  }

  el.append(card, hudA, hudI);
  viewport.appendChild(el);

  const p = {
    el, card,
    x: Number(meta.x || 0),
    y: Number(meta.y || 0),
    tx: Number(meta.x || 0),
    ty: Number(meta.y || 0),
    baseTx: Number(meta.x || 0),
    baseTy: Number(meta.y || 0),
    phase: Math.random()*Math.PI*2,
    dragging: false,
    moved: 0,
    s: 1,
    ts: 1,
    suppressClickUntil: 0
  };
  pieces.push(p);

  /* DRAG: do NOT open HUDs */
  el\.addEventListener\(\"pointerdown\", e => \{
    if\(isMobile && !e\.target\.closest\(\"\.card\"\)\) return;
    // v6-5 mobile: only the top card in Zone 1 can be dragged out
    if(isMobile){
      const z = mobileZone.get(p)||'z1';
      if(z==='z1'){
        const top = deckTop();
        if(top !== p) return;
      }else{
        // cards already placed are not draggable in this mode
        return;
      }
    }

    // Only start interactions when the user touches the card surface (not HUDs/controls).
    if(!e.target.closest(".card")) return;
    if(e.target.closest(".hud") || e.target.closest(".flipBtn") || e.target.closest(".irBtn") || e.target.closest("button") || e.target.closest("a")) return;
    p.dragging = true;
    p.moved = 0;
    p.startX = e.clientX;
    p.startY = e.clientY;
    p.baseX = p.tx;
    p.baseY = p.ty;
    el.setPointerCapture(e.pointerId);
    el.style.zIndex = ++zTop;
  });
  el.addEventListener("pointermove", e => {
    if(!p.dragging) return;
    const dx = (e.clientX - p.startX) / scale;
    const dy = (e.clientY - p.startY) / scale;
    p.moved = Math.max(p.moved, Math.abs(dx)+Math.abs(dy));
    p.tx = p.baseX + dx;
    p.ty = p.baseY + dy;
  });
  el.addEventListener("pointerup", (e) => {
    if(!p.dragging) return;
    p.dragging = false;
    if(p.moved > 6){
      p.suppressClickUntil = performance.now() + 250;
    }
  });

    /* CLICK toggles HUDs (only if not dragged) */
  el\.addEventListener\(\"click\", e => \{
    if\(e\.target\.closest\(\"\.flipBtn\"\) \|\| e\.target\.closest\(\"\.irBtn\"\)\) return;
    if\(performance\.now\(\) < p\.suppressClickUntil\) return;

    // v6-5 mobile click sequence (top card preview -> HUDs)
    if(isMobile){
      const z = mobileZone.get(p)||'z1';
      if(z==='z1'){
        const top = deckTop();
        if(top !== p) return; // only top card is interactive
        // First click: enlarge + glow (no HUD)
        if(p.ts < 2.0){
          closeAllHUD();
          clearSelection();
          p.ts = 3;
          p.el.classList.add('lit');
          refreshDeckVisibility();
          return;
        }
      }
    }

    // SOLO FRONTAL: no seleccionar/abrir HUD si estamos viendo el BACK
    if(card.classList.contains("flipped")) return;

    const willOpen = !el.classList.contains("hudOpen");
    closeAllHUD();

    // Glow de selecci√≥n
    if(selectedPiece && selectedPiece !== p) selectedPiece.el.classList.remove("selected");
    selectedPiece = p;
    el.classList.add("selected");

    if(willOpen){
      el.classList.add("flash");
      setTimeout(()=>el.classList.remove("flash"), 210);
      el.classList.add("hudOpen");
    }
  });

  return p;
}

/* LOAD MANIFEST */
function loadManifest(data){
  viewport.querySelectorAll(".piece").forEach(e => e.remove());
  pieces = [];
  zTop = 10;
  clearSelection();
  if(!data || !Array.isArray(data.cards)){
    alert("Manifest inv√°lido");
    return;
  }
  data.cards.forEach((m)=>{ const p=createPiece(m); if(isMobile){ setZone(p,'z1'); } });
  totalEl.innerHTML = `TOTAL: <span class="num">${data.cards.length}</span>`;
  if(isMobile){ zRead=[]; zPending=[]; syncCounts(); requestAnimationFrame(()=>{ layoutMobileZones(); refreshDeckVisibility(); }); }
  stackCenter();
}

fetch("manifest/manifest.json", {cache:"no-store"}).then(r=>r.json()).then(loadManifest).catch(()=>{});

/* HEADER BUTTONS */
function stackCenter(){
  if(!pieces.length) return;
  closeAllHUD();
  clearSelection();

  if(isMobile){
    zRead=[]; zPending=[];
    pieces.forEach((p,i)=>{ setZone(p,'z1'); p.el.style.zIndex = (i+1); p.ts = 1; p.el.classList.remove('lit'); p.el.classList.remove('hudOpen'); });
    zTop = pieces.length + 5;
    syncCounts();
    scale=1; panX=0; panY=0;
    updateBgMetrics();
    updateView();
    requestAnimationFrame(()=>{ layoutMobileZones(); refreshDeckVisibility(); });
    return;
  }

  const rect = stage.getBoundingClientRect();
  const cs = getComputedStyle(document.documentElement);
  const cardW = parseFloat(cs.getPropertyValue("--cardW")) || 175;
  const cardH = parseFloat(cs.getPropertyValue("--cardH")) || 246;

  const cx = (rect.width/2) - (cardW/2);
  const cy = (rect.height/2) - (cardH/2);

  pieces.forEach((p,i)=>{
    p.tx = cx;
    p.ty = cy;
    p.el.style.zIndex = i+1;
  });
  zTop = pieces.length + 5;

  // Home view: deck centered, slightly closer on mobile.
  scale = homeScale;
  panX = 0;
  panY = 0;
  updateView();
}

function dealRandom(){
  if(!pieces.length) return;
  closeAllHUD();
  clearSelection();

  if(isMobile){
    zRead=[]; zPending=[];
    pieces.forEach((p,i)=>{ setZone(p,'z1'); p.el.style.zIndex = (i+1); p.ts = 1; p.el.classList.remove('lit'); p.el.classList.remove('hudOpen'); });
    zTop = pieces.length + 5;
    syncCounts();
    scale=1; panX=0; panY=0;
    updateBgMetrics();
    updateView();
    requestAnimationFrame(()=>{ layoutMobileZones(); refreshDeckVisibility(); });
    return;
  }
  closeAllHUD();
  const rect = stage.getBoundingClientRect();
  const maxX = Math.max(0, rect.width/scale - 175 - 12);
  const maxY = Math.max(0, rect.height/scale - 246 - 12);
  pieces.forEach(p=>{
    p.tx = 6 + Math.random()*maxX;
    p.ty = 6 + Math.random()*maxY;
    p.el.style.zIndex = ++zTop;
  });
}

function drawOne(){
  // v6-5 mobile: "SACAR UNA" highlights the top card (doesn't advance deck)
  if(isMobile){
    if(!pieces.length) return;
    closeAllHUD();
    clearSelection();
    const p = deckTop();
    if(!p) return;
    p.el.style.zIndex = ++zTop;
    p.ts = 3;
    p.el.classList.add('lit');
    // small nudge like reveal
    p.tx += 6; p.ty += 6;
    p.el.classList.add('flash');
    setTimeout(()=>p.el.classList.remove('flash'), 210);
    refreshDeckVisibility();
    return;
  }
  if(!pieces.length) return;
  closeAllHUD();
  clearSelection();
  closeAllHUD();
  const p = pieces[Math.floor(Math.random()*pieces.length)];
  p.el.style.zIndex = ++zTop;
  p.tx += 18;
  p.ty += 18;
  p.el.classList.add("flash");
  setTimeout(()=>p.el.classList.remove("flash"), 210);
}
  if(!pieces.length) return;
  closeAllHUD();
  clearSelection();

  if(isMobile){
    zRead=[]; zPending=[];
    pieces.forEach((p,i)=>{ setZone(p,'z1'); p.el.style.zIndex = (i+1); p.ts = 1; p.el.classList.remove('lit'); p.el.classList.remove('hudOpen'); });
    zTop = pieces.length + 5;
    syncCounts();
    scale=1; panX=0; panY=0;
    updateBgMetrics();
    updateView();
    requestAnimationFrame(()=>{ layoutMobileZones(); refreshDeckVisibility(); });
    return;
  }
  closeAllHUD();
  const p = pieces[Math.floor(Math.random()*pieces.length)];
  p.el.style.zIndex = ++zTop;
  p.tx += 18;
  p.ty += 18;
  p.el.classList.add("flash");
  setTimeout(()=>p.el.classList.remove("flash"), 210);
}

btnDeck.addEventListener("click", () => {
  if(isMobile){
    if(confirm("¬øReiniciar Mazo?")) stackCenter();
    return;
  }
  stackCenter();
});
btnDeal.addEventListener("click", dealRandom);
btnDraw.addEventListener("click", drawOne);
btnMove.addEventListener("click", () => {
  moverOn = !moverOn;
  btnMove.classList.toggle("active", moverOn);
});
btnFrame.addEventListener("click", () => {
  closeAllHUD();
  clearSelection();

  if(isMobile){
    zRead=[]; zPending=[];
    pieces.forEach((p,i)=>{ setZone(p,'z1'); p.el.style.zIndex = (i+1); p.ts = 1; p.el.classList.remove('lit'); p.el.classList.remove('hudOpen'); });
    zTop = pieces.length + 5;
    syncCounts();
    scale=1; panX=0; panY=0;
    updateBgMetrics();
    updateView();
    requestAnimationFrame(()=>{ layoutMobileZones(); refreshDeckVisibility(); });
    return;
  }
  scale = homeScale;
  panX = 0;
  panY = 0;
  updateView();
});

/* CLICK OUTSIDE closes HUDs */
document.addEventListener("pointerdown", (e)=>{
  if(e.target.closest("header")) return;
  if(e.target.closest(".piece")) return;
  closeAllHUD();
  clearSelection();

  if(isMobile){
    zRead=[]; zPending=[];
    pieces.forEach((p,i)=>{ setZone(p,'z1'); p.el.style.zIndex = (i+1); p.ts = 1; p.el.classList.remove('lit'); p.el.classList.remove('hudOpen'); });
    zTop = pieces.length + 5;
    syncCounts();
    scale=1; panX=0; panY=0;
    updateBgMetrics();
    updateView();
    requestAnimationFrame(()=>{ layoutMobileZones(); refreshDeckVisibility(); });
    return;
  }
}, {capture:true});

/* PAN (clamped to BG) */
let panning=false, psx=0, psy=0, basePanX=0, basePanY=0, pid=null;
stage.addEventListener("pointerdown", e=>{
  if(isMobile) return;
  if(e.target.closest(".card")) return;
  panning=true;
  stage.classList.add("panning");
  psx = e.clientX; psy = e.clientY;
  basePanX = panX; basePanY = panY;
  pid = e.pointerId;
});
window.addEventListener("pointermove", e=>{
  if(!panning || e.pointerId!==pid) return;
  panX = basePanX + (e.clientX-psx);
  panY = basePanY + (e.clientY-psy);
  updateView();
});
window.addEventListener("pointerup", e=>{
  if(e.pointerId!==pid) return;
  panning=false;
  stage.classList.remove("panning");
});

/* ZOOM to cursor (locked minScale) */
stage.addEventListener("wheel", e=>{
  if(isMobile) return;
  e.preventDefault();
  const rect = stage.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const baseX = panX;
  const baseY = panY;

  const worldX = (mx - baseX) / scale;
  const worldY = (my - baseY) / scale;

  const factor = e.deltaY < 0 ? 1.1 : 0.9;
  const newScale = Math.max(minScale, Math.min(maxScale, scale*factor));

  const newBaseX = mx - worldX * newScale;
  const newBaseY = my - worldY * newScale;
  panX = newBaseX; panY = newBaseY;
  scale = newScale;
  updateView();
},{passive:false});


/* PINCH ZOOM (mobile) */
const pointers = new Map(); // id -> {x,y}
let pinchStartDist = 0;
let pinchStartScale = 1;
let pinchWorldX = 0;
let pinchWorldY = 0;

function dist(a,b){
  const dx = a.x-b.x, dy = a.y-b.y;
  return Math.hypot(dx,dy);
}
function mid(a,b){
  return {x:(a.x+b.x)/2, y:(a.y+b.y)/2};
}

stage.addEventListener("pointerdown", e=>{
  if(isMobile) return; // v6-4: lock camera on mobile
  // Ignore touches that start on cards to avoid confusing zoom/drag.
  if(e.target.closest(".card")) return;
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
  // prevent default touch scrolling on mobile
  if(isMobile) e.preventDefault();

  // If the user puts a second finger down, initialize pinch immediately.
  if(pointers.size === 2){
    const [a,b] = Array.from(pointers.values());
    pinchStartDist = dist(a,b);
    pinchStartScale = scale;

    const m = mid(a,b);
    const rect = stage.getBoundingClientRect();
    const mx = m.x - rect.left;
    const my = m.y - rect.top;
    pinchWorldX = (mx - panX) / scale;
    pinchWorldY = (my - panY) / scale;
  }
},{passive:false});

stage.addEventListener("pointermove", e=>{
  if(isMobile) return; // v6-4: lock camera on mobile
  if(!pointers.has(e.pointerId)) return;
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

  if(pointers.size === 2){
    // stop single-finger panning while pinching
    panning = false;
    stage.classList.remove("panning");

    const [a,b] = Array.from(pointers.values());
    const m = mid(a,b);
    const rect = stage.getBoundingClientRect();
    const mx = m.x - rect.left;
    const my = m.y - rect.top;

    const d = dist(a,b);
    // pinchStartDist is initialized on the second finger down.
    const factor = d / Math.max(1e-6, pinchStartDist);
    const newScale = Math.max(minScale, Math.min(maxScale, pinchStartScale * factor));

    const newBaseX = mx - pinchWorldX * newScale;
    const newBaseY = my - pinchWorldY * newScale;
    panX = newBaseX; panY = newBaseY;
    scale = newScale;
    updateView();
  }
},{passive:false});

window.addEventListener("pointerup", e=>{
  pointers.delete(e.pointerId);
  if(pointers.size < 2){
    pinchStartDist = 0;
  }
});
window.addEventListener("pointercancel", e=>{
  pointers.delete(e.pointerId);
  pinchStartDist = 0;
});

/* LOOP */
function tick(){
  const t = performance.now()*0.002;
  for(const p of pieces){
    if(moverOn && !p.dragging){
      if(isMobile){
        p.tx = p.baseTx + Math.sin(t + p.phase) * 10;
        p.ty = p.baseTy + Math.cos(t*0.9 + p.phase*1.3) * 10;
      }else{
        p.tx += Math.sin(t + p.phase) * 0.35;
        p.ty += Math.cos(t*0.9 + p.phase*1.3) * 0.35;
      }
    }
    p.x += (p.tx - p.x) * (isMobile ? 0.35 : 0.15);
    p.y += (p.ty - p.y) * (isMobile ? 0.35 : 0.15);
    p.s += (p.ts - p.s) * 0.22;
    p.el.style.transform = `translate(${p.x}px,${p.y}px) scale(${p.s})`;
  }
  requestAnimationFrame(tick);
}
tick();
updateBgMetrics();
updateView();
if(isMobile){ requestAnimationFrame(()=>{ layoutMobileZones(); refreshDeckVisibility(); }); }

window.addEventListener("resize", ()=>{
  updateBgMetrics();
  updateView();
});

/* ===== v3-5: header micro-animations ===== */
document.querySelectorAll("header .hdrBtn .lbl").forEach(l => {
  l.setAttribute("data-txt", l.textContent.trim());
});

(function headerGlitchLoop(){
  const btns = Array.from(document.querySelectorAll("header .hdrBtn"));
  if(!btns.length) return;
  setInterval(() => {
    const b = btns[(Math.random()*btns.length)|0];
    b.classList.add("glitch");
    setTimeout(()=>b.classList.remove("glitch"), 260);
  }, 4200);
})();
/* ===== end v3-5 ===== */


/* ===== v5-1: FX overlay (dust + lights) ===== */
(() => {
  const cShade  = document.getElementById('shade');
  const cLight  = document.getElementById('lightMap');
  const cDust   = document.getElementById('dust');
  if(!cShade || !cLight || !cDust) return;

  const ctxS = cShade.getContext('2d', {alpha:true});
  const ctxL = cLight.getContext('2d', {alpha:true});
  const ctxD = cDust.getContext('2d', {alpha:true});

  let W=0,H=0,dpr=1;

  const rand=(a,b)=>a+Math.random()*(b-a);

  function resize(){
    // cap DPR to keep perf stable while still looking crisp
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth*dpr);
    H = Math.floor(innerHeight*dpr);
    [cShade,cLight,cDust].forEach(c=>{ c.width=W; c.height=H; });
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  /* ===== Slow Lights (white + teal) ===== */
  const lights=[];
  function seedLights(n=16){
    lights.length=0;
    for(let i=0;i<n;i++){
      const speed=rand(0.000010, 0.000028);
      const ang=rand(0,Math.PI*2);
      lights.push({
        x: rand(0.06,0.94),
        y: rand(0.08,0.92),
        vx: Math.cos(ang)*speed,
        vy: Math.sin(ang)*speed*0.75,
        r:  rand(0.15,0.32),
        hue: (Math.random()<0.52) ? 'teal' : 'white',
        phase: rand(0,Math.PI*2),
        pulse: rand(0.8,1.7),
        wob: rand(0.6,1.6),
        intensity: rand(0.8,1.35),
      });
    }
  }
  seedLights();

  function stepLights(t, dt){
    for(const L of lights){
      const ax = 0.00000002 * Math.sin(t*0.00035*L.wob + L.phase);
      const ay = 0.00000002 * Math.cos(t*0.00031*L.wob + L.phase*1.3);
      L.vx += ax; L.vy += ay;

      const vmax = 0.000055;
      L.vx = Math.max(-vmax, Math.min(vmax, L.vx));
      L.vy = Math.max(-vmax, Math.min(vmax, L.vy));

      L.x += L.vx * dt;
      L.y += L.vy * dt;

      if(L.x < -0.08) L.x = 1.08;
      if(L.x >  1.08) L.x = -0.08;
      if(L.y < -0.08) L.y = 1.08;
      if(L.y >  1.08) L.y = -0.08;
    }
  }

  /* ===== Constant Dust Movement ===== */
  const dust=[];
  function seedDust(n=520){
    dust.length=0;
    for(let i=0;i<n;i++){
      dust.push({
        x: Math.random(),
        y: Math.random(),
        z: rand(0.25, 1.35),
        r: rand(0.55, 2.3),
        vx: rand(-0.00004,0.00004),
        vy: rand(-0.00003,0.00003),
        ph: rand(0, Math.PI*2),
        tw: rand(0.8, 2.1),
      });
    }
  }
  seedDust();

  function drawLighting(t){
    ctxL.clearRect(0,0,W,H);

    ctxS.clearRect(0,0,W,H);
    ctxS.globalCompositeOperation='source-over';
    ctxS.fillStyle='rgba(0,0,0,0.93)';
    ctxS.fillRect(0,0,W,H);
    ctxS.globalCompositeOperation='destination-out';

    for(const L of lights){
      const px=L.x*W, py=L.y*H;
      const pr=L.r*Math.min(W,H);
      const pulse = 0.60 + 0.40*Math.sin(t*0.0018*L.pulse + L.phase);
      const I = 0.92 * L.intensity * pulse;

      const col = (L.hue==='teal')
        ? `rgba(45,212,191,${I})`
        : `rgba(255,255,255,${I})`;

      const g=ctxL.createRadialGradient(px,py,0,px,py,pr);
      g.addColorStop(0, col);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctxL.fillStyle=g;
      ctxL.beginPath(); ctxL.arc(px,py,pr,0,Math.PI*2); ctxL.fill();

      const holeR = pr*1.18;
      const gs=ctxS.createRadialGradient(px,py,0,px,py,holeR);
      gs.addColorStop(0,'rgba(0,0,0,0.99)');
      gs.addColorStop(0.30,'rgba(0,0,0,0.65)');
      gs.addColorStop(1,'rgba(0,0,0,0)');
      ctxS.fillStyle=gs;
      ctxS.beginPath(); ctxS.arc(px,py,holeR,0,Math.PI*2); ctxS.fill();
    }

    ctxS.globalCompositeOperation='source-over';
  }

  function drawDust(t, dt){
    ctxD.clearRect(0,0,W,H);

    for(const p of dust){
      p.x += p.vx * dt;
      p.y += p.vy * dt;

      if(p.x < -0.12) p.x = 1.12;
      if(p.x >  1.12) p.x = -0.12;
      if(p.y < -0.12) p.y = 1.12;
      if(p.y >  1.12) p.y = -0.12;

      const px=p.x*W, py=p.y*H;
      const pr=p.r*dpr*(0.65+p.z);
      const tw = 0.35 + 0.65*Math.sin(t*0.0019*p.tw + p.ph);
      const a = (0.10 + 0.22*tw) * Math.min(1.0, 0.80*p.z);

      const g = ctxD.createRadialGradient(px,py,0,px,py,pr*7.4);
      g.addColorStop(0, `rgba(220,240,255,${a})`);
      g.addColorStop(0.35, `rgba(180,220,255,${a*0.55})`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctxD.fillStyle=g;
      ctxD.beginPath(); ctxD.arc(px,py,pr*7.4,0,Math.PI*2); ctxD.fill();
    }
  }

  let last=performance.now();
  function loop(t){
    const dt = Math.min(50, t-last);
    last = t;

    stepLights(t, dt);
    drawLighting(t);
    drawDust(t, dt);

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
 /* ===== end v5-1 FX ===== */


</script>

</body>
</html>
