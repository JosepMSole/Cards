<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Deck v4-3</title>

<style>
:root{
  --cardW:175px;
  --cardH:246px;
  --headerH:90px;
  --hudDur:.5s;
}
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  background:#070b18;
  font-family:system-ui;
  color:white;
}
header{
  position:fixed;
  top:0;left:0;right:0;
  height:var(--headerH);
  background:black;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:12px;
  z-index:1000;
}
header button{
  padding:10px 14px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.2);
  background:rgba(255,255,255,.08);
  color:white;
  font-weight:800;
  cursor:pointer;
  user-select:none;
}
header button.active{
  background:rgba(124,92,255,.4);
  box-shadow:0 0 18px rgba(124,92,255,.35);
}
#total{
  padding:10px 14px;
  border-radius:14px;
  background:rgba(255,255,255,.1);
  border:1px solid rgba(255,255,255,.2);
  font-weight:900;
}

/* ===== v3-5 HEADER FX ===== */
header{
  position:fixed;
  top:0;left:0;right:0;
  height:var(--headerH);
  background:
    radial-gradient(1200px 120px at 50% 0%, rgba(124,92,255,.22), transparent 70%),
    linear-gradient(180deg, rgba(0,0,0,.92), rgba(0,0,0,.78));
  border-bottom:1px solid rgba(255,255,255,.10);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  overflow:hidden;
}
header::before{
  content:"";
  position:absolute;
  inset:-40px -60px;
  background:
    repeating-linear-gradient(
      180deg,
      rgba(255,255,255,.045) 0px,
      rgba(255,255,255,.045) 1px,
      transparent 2px,
      transparent 6px
    );
  opacity:.25;
  mix-blend-mode:overlay;
  pointer-events:none;
  animation:scanMove 4.5s linear infinite;
}
header::after{
  content:"";
  position:absolute;
  inset:0;
  background: radial-gradient(600px 90px at 50% 10%, rgba(45,212,191,.10), transparent 65%);
  opacity:.8;
  pointer-events:none;
}
@keyframes scanMove{
  0%{ transform:translateY(0); }
  100%{ transform:translateY(46px); }
}

header button.hdrBtn{
  position:relative;
  padding:10px 14px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.18);
  background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
  color:white;
  font-weight:900;
  cursor:pointer;
  user-select:none;
  display:flex;
  align-items:center;
  gap:10px;
  letter-spacing:.4px;
  text-shadow:0 1px 0 rgba(0,0,0,.55);
  transform:translateZ(0);
  transition:
    transform .12s ease,
    box-shadow .18s ease,
    border-color .18s ease,
    filter .18s ease;
  isolation:isolate;
}
header button.hdrBtn .ico{
  font-size:18px;
  line-height:1;
  filter:drop-shadow(0 0 10px rgba(124,92,255,.25));
}
header button.hdrBtn::before{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius:16px;
  background:
    radial-gradient(160px 36px at 20% 0%, rgba(45,212,191,.22), transparent 60%),
    radial-gradient(180px 42px at 80% 100%, rgba(124,92,255,.18), transparent 60%);
  opacity:.0;
  transition:opacity .18s ease;
  pointer-events:none;
  z-index:-1;
}
header button.hdrBtn::after{
  content:"";
  position:absolute;
  inset:0;
  border-radius:14px;
  background:linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
  transform:translateX(-140%);
  opacity:.0;
  pointer-events:none;
  mix-blend-mode:screen;
}
header button.hdrBtn:hover{
  transform:translateY(-1px);
  border-color:rgba(124,92,255,.35);
  box-shadow:0 0 0 1px rgba(124,92,255,.10), 0 0 26px rgba(124,92,255,.22);
  filter:saturate(1.15) brightness(1.05);
}
header button.hdrBtn:hover::before{ opacity:1; }
header button.hdrBtn:hover::after{
  opacity:.55;
  animation:btnSheen .7s ease;
}
@keyframes btnSheen{
  0%{ transform:translateX(-140%); }
  100%{ transform:translateX(140%); }
}
header button.hdrBtn:active{
  transform:translateY(0px) scale(.985);
  filter:brightness(1.08);
}

/* Glitch pulse (applied via JS occasionally) */
header button.hdrBtn.glitch{
  animation:glitchJolt .24s steps(2,end) 1;
}
header button.hdrBtn.glitch .lbl{
  position:relative;
}
header button.hdrBtn.glitch .lbl::before,
header button.hdrBtn.glitch .lbl::after{
  content:attr(data-txt);
  position:absolute;
  left:0; top:0;
  opacity:.65;
  pointer-events:none;
}
header button.hdrBtn.glitch .lbl::before{
  transform:translate(1px,-1px);
  color:rgba(45,212,191,.9);
  clip-path:inset(0 0 55% 0);
}
header button.hdrBtn.glitch .lbl::after{
  transform:translate(-1px,1px);
  color:rgba(255,80,120,.9);
  clip-path:inset(55% 0 0 0);
}
@keyframes glitchJolt{
  0%{ transform:translateY(-1px) skewX(0deg); }
  50%{ transform:translateY(-1px) skewX(6deg); }
  100%{ transform:translateY(-1px) skewX(0deg); }
}

header button.active,
header button.hdrBtn.active{
  background:rgba(124,92,255,.40);
  box-shadow:0 0 18px rgba(124,92,255,.35);
  border-color:rgba(124,92,255,.45);
}
/* ===== end v3-5 header fx ===== */

#stage{
  position:fixed;
  inset:var(--headerH) 0 0 0;
  overflow:hidden;
  touch-action:none;
  cursor:grab;
  background:#070b18;
}
#stage.panning{ cursor:grabbing; }

#viewport{
  position:absolute;
  inset:0;
  transform-origin:0 0;
  will-change:transform;
  z-index:1;
}

#bg{
  position:absolute;
  left:0;
  top:0;
  width:100%;
  height:100%;
  transform-origin:0 0;
  will-change:transform;
  z-index:0;
  pointer-events:none;
  background:
    radial-gradient(1200px 800px at 40% 30%, rgba(124,92,255,.25), transparent 60%),
    radial-gradient(900px 600px at 70% 60%, rgba(255,202,58,.18), transparent 55%),
    url("images/bg.jpg") center/cover no-repeat;
}

/* CARD */
.piece{
  position:absolute;
  z-index:1;
  width:var(--cardW);
  height:var(--cardH);
  perspective:1200px;
  -webkit-perspective:1200px;
  transform-style:preserve-3d;
  -webkit-transform-style:preserve-3d;
  touch-action:none;
}

.card{
  position:absolute;
  inset:0;
  border-radius:18px;
  overflow:hidden;
  box-shadow:0 14px 40px rgba(0,0,0,.6);

  background: transparent;z-index:2;

  transform-style:preserve-3d;
  -webkit-transform-style:preserve-3d;
  will-change:transform;
}

/* Each face rotates, not the parent (more reliable across browsers). */
.face{
  position:absolute;
  inset:0;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;

  backface-visibility:hidden;
  -webkit-backface-visibility:hidden;

  transition:transform .45s cubic-bezier(.2,.7,.2,1);
  will-change:transform;

  /* micro translateZ helps avoid front "bleeding" through on some GPUs */
  transform:translateZ(0.5px);

  transform-style:preserve-3d;
  -webkit-transform-style:preserve-3d;

  image-rendering:auto;
}

.front{ transform:rotateY(0deg) translateZ(0.5px); }
.back { transform:rotateY(180deg) translateZ(0.5px); background-color:#111; }

.card.flipped .front{ transform:rotateY(-180deg) translateZ(0.5px); }
.card.flipped .back { transform:rotateY(0deg) translateZ(0.5px); }

/* Flip button: always top-right, regardless of face */
.flipBtn{
  position:absolute;
  top:8px; right:8px;
  width:40px;height:40px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.2);
  background:rgba(0,0,0,.4);
  color:white;
  font-weight:900;
  cursor:pointer;
  z-index:6;
  user-select:none;
}

/* HUD */
.hudAction,.hudInfo{
  position:absolute;
  border-radius:18px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(15,23,48,.95);
  box-shadow:0 12px 34px rgba(0,0,0,.6);
  opacity:0;
  transition:opacity var(--hudDur) ease, transform var(--hudDur) cubic-bezier(.2,.7,.2,1);
  pointer-events:auto;
  z-index:1;
}
.hudAction{
  width:140px;height:120px;
  left:-140px;
  top:calc((var(--cardH) - 120px)/2);
  display:flex;align-items:center;justify-content:center;
  transform:translateX(40px);
}
.hudInfo{
  min-width:200px;
  max-width:280px;
  left:var(--cardW);
  top:0;
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:10px;
  transform:translateX(-40px);
}
.piece.hudOpen .hudAction,
.piece.hudOpen .hudInfo{
  opacity:1;
  transform:translateX(0);
}
.irBtn{
  width:66px;height:66px;border-radius:18px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(45,212,191,.3);
  color:#fff;font-weight:1000;cursor:pointer;
}
.infoThumb{
  width:100%;
  aspect-ratio:16/9;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.10);
  background-color: rgba(255,255,255,.06);
}
.infoText{
  font-size:13px;
  white-space:pre-wrap;
  line-height:1.25;
}

/* Flash */
@keyframes wildFlash{
  0%{ filter:brightness(1) contrast(1); transform:scale(1); }
  20%{ filter:brightness(3) contrast(2.4) saturate(1.6); transform:scale(1.08) rotate(-3deg); }
  50%{ transform:scale(1.05) rotate(3deg); }
  100%{ filter:brightness(1) contrast(1); transform:scale(1); }
}
.piece.flash .card,
.piece.flash .hudAction,
.piece.flash .hudInfo{ animation:wildFlash .2s ease; }

/* Hide card shadow during flip to avoid static shadow plane */
.piece.flipping .card{ box-shadow:none !important; }

/* Selected glow (only on front-click) */
.piece.selected .card{
  box-shadow:
    0 14px 40px rgba(0,0,0,.6),
    0 0 0 2px rgba(124,92,255,.55),
    0 0 28px rgba(124,92,255,.55),
    0 0 58px rgba(124,92,255,.35);
}

/* ===== v4-1 MOBILE LAYOUT (only mobile) ===== */
@media (max-width: 768px){
  :root{
    /* mobile: slightly larger cards (still many visible) */
    --cardW:78px;
    --cardH:110px;
    /* taller header + 2-row wrap */
    --headerH:132px;
  }
  header{
    padding:8px 10px 8px;
    justify-content:center;
    align-items:center;
    flex-wrap:wrap;
    column-gap:8px;
    row-gap:4px;
  }
  header button.hdrBtn{
    padding:8px 10px;
    border-radius:14px;
    font-size:12px;
    gap:8px;
  }
  header button.hdrBtn .ico{ font-size:16px; }
  #total{
    padding:8px 10px;
    border-radius:14px;
    font-size:12px;
    width:fit-content;
  }
  .flipBtn{
    width:28px;height:28px;
    border-radius:10px;
    top:6px; right:6px;
    font-size:14px;
  }
  .hudAction{
    width:110px;height:92px;
    left:-110px;
    top:calc((var(--cardH) - 92px)/2);
  }
  .irBtn{ width:54px;height:54px;border-radius:16px; }
  .hudInfo{
    left:var(--cardW);
    max-width:220px;
    padding:10px;
  }
}
/* ===== end v4-1 mobile ===== */

</style>
</head>
<body>

<header>
<button id="btnDeck" class="hdrBtn"><span class="ico" aria-hidden="true">üÇ†</span><span class="lbl">MAZO</span></button>
<button id="btnDraw" class="hdrBtn"><span class="ico" aria-hidden="true">üé¥</span><span class="lbl">SACAR UNA</span></button>
<button id="btnDeal" class="hdrBtn"><span class="ico" aria-hidden="true">üÉè</span><span class="lbl">REPARTIR</span></button>
<button id="btnMove" class="hdrBtn"><span class="ico" aria-hidden="true">üåÄ</span><span class="lbl">MOVER</span></button>
<button id="btnFrame" class="hdrBtn"><span class="ico" aria-hidden="true">üéØ</span><span class="lbl">ENCUADRAR</span></button>
<div id="total">TOTAL: 0</div>
</header>

<div id="stage">
  <div id="bg"></div>
  <div id="viewport"></div>
</div>

<script>
const viewport = document.getElementById("viewport");
const stage = document.getElementById("stage");
const bg = document.getElementById("bg");
const totalEl = document.getElementById("total");

const btnDeck  = document.getElementById("btnDeck");
const btnDraw  = document.getElementById("btnDraw");
const btnDeal  = document.getElementById("btnDeal");
const btnMove  = document.getElementById("btnMove");
const btnFrame = document.getElementById("btnFrame");

const isMobile = window.matchMedia && window.matchMedia("(max-width: 768px)").matches;
let maxScale = isMobile ? 5.0 : 2.5;

let pieces = [];
let selectedPiece = null;
let scale = 1, panX = 0, panY = 0;
let minScale = isMobile ? 0.6 : 1;          // allow more zoom-out on mobile
let homeScale = isMobile ? 1.0 : 1;

// BG overscan so it never reveals black margins, while still moving with zoom.
let bgBaseW = 0, bgBaseH = 0, bgOffX = 0, bgOffY = 0;
function updateBgMetrics(){
  const rect = stage.getBoundingClientRect();
  // Make BG large enough so that even at minScale it still covers the stage.
  const overscan = 1.06; // small safety margin
  bgBaseW = rect.width / Math.max(0.0001, minScale) * overscan;
  bgBaseH = rect.height / Math.max(0.0001, minScale) * overscan;

  // Center the BG around the stage at pan=0.
  bgOffX = -(bgBaseW - rect.width) / 2;
  bgOffY = -(bgBaseH - rect.height) / 2;

  bg.style.width = bgBaseW + "px";
  bg.style.height = bgBaseH + "px";
  bg.style.left = "0px";
  bg.style.top = "0px";
}
         // initial framing (closer than minScale)
let moverOn = false;
let zTop = 10;

function clampPan(){
  // Clamp based on BG bounds so we never expose black margins.
  const rect = stage.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  if(!bgBaseW || !bgBaseH) updateBgMetrics();

  const bgW = bgBaseW * scale;
  const bgH = bgBaseH * scale;

  // BG screen-space left/top is (pan + bgOff). Keep left<=0 and right>=w (same for Y).
  const minPanX = w - (bgOffX + bgW);
  const maxPanX = -bgOffX;
  const minPanY = h - (bgOffY + bgH);
  const maxPanY = -bgOffY;

  panX = Math.min(maxPanX, Math.max(minPanX, panX));
  panY = Math.min(maxPanY, Math.max(minPanY, panY));
}

function updateView(){
  clampPan();
  viewport.style.transform = `translate(${panX}px,${panY}px) scale(${scale})`;
  bg.style.transform = `translate(${panX + bgOffX}px,${panY + bgOffY}px) scale(${scale})`;
}

function clearSelection(){
  if(selectedPiece){
    selectedPiece.el.classList.remove("selected");
    selectedPiece = null;
  }
}

function closeAllHUD(){
  pieces.forEach(p => p.el.classList.remove("hudOpen"));
}

/* CREATE CARD */
function createPiece(meta){
  const el = document.createElement("div");
  el.className = "piece";
  el.style.zIndex = ++zTop;

  const card = document.createElement("div");
  card.className = "card";

  const front = document.createElement("div");
  front.className = "face front";
  if(meta.front){
    const u = encodeURI("images/" + meta.front);
    front.style.backgroundImage = `url("${u}")`;
  }

  const back = document.createElement("div");
  back.className = "face back";
  if(meta.back){
    const u = encodeURI("images/" + meta.back);
    back.style.backgroundImage = `url("${u}")`;
  }

  // Flip button is duplicated: one on FRONT and one on BACK so it always sits top-right
  // and rotates with the visible face (no "plane staying still" during flip).
  const mkFlipBtn = () => {
    const b = document.createElement("button");
    b.className = "flipBtn";
    b.textContent = "‚Üª";
    b.addEventListener("pointerdown", e => { e.stopPropagation(); });
    b.addEventListener("click", e => { e.stopPropagation(); el.classList.add("flipping"); card.classList.toggle("flipped"); closeAllHUD(); setTimeout(()=>el.classList.remove("flipping"), 520); });
    return b;
  };
  front.appendChild(mkFlipBtn());
  back.appendChild(mkFlipBtn());

  card.append(front, back);

  const hudA = document.createElement("div");
  hudA.className = "hudAction";
  const ir = document.createElement("button");
  ir.className = "irBtn";
  ir.textContent = "IR";
  ir.addEventListener("pointerdown", e => e.stopPropagation());
  ir.addEventListener("click", e => {
    e.stopPropagation();
    if(meta.url) window.open(meta.url, "_blank", "noopener,noreferrer");
  });
  hudA.appendChild(ir);

  const hudI = document.createElement("div");
  hudI.className = "hudInfo";
  if(meta.hud){
    const thumb = document.createElement("div");
    thumb.className = "infoThumb";
    thumb.style.backgroundImage = `url("images/${meta.hud}")`;
    hudI.appendChild(thumb);
  }
  if(meta.hudText){
    const text = document.createElement("div");
    text.className = "infoText";
    text.textContent = meta.hudText;
    hudI.appendChild(text);
  }

  el.append(card, hudA, hudI);
  viewport.appendChild(el);

  const p = {
    el, card,
    x: Number(meta.x || 0),
    y: Number(meta.y || 0),
    tx: Number(meta.x || 0),
    ty: Number(meta.y || 0),
    phase: Math.random()*Math.PI*2,
    dragging: false,
    moved: 0,
    suppressClickUntil: 0
  };
  pieces.push(p);

  /* DRAG: do NOT open HUDs */
  el.addEventListener("pointerdown", e => {
    // Only start interactions when the user touches the card surface (not HUDs/controls).
    if(!e.target.closest(".card")) return;
    if(e.target.closest(".hud") || e.target.closest(".flipBtn") || e.target.closest(".irBtn") || e.target.closest("button") || e.target.closest("a")) return;
    p.dragging = true;
    p.moved = 0;
    p.startX = e.clientX;
    p.startY = e.clientY;
    p.baseX = p.tx;
    p.baseY = p.ty;
    el.setPointerCapture(e.pointerId);
    el.style.zIndex = ++zTop;
  });
  el.addEventListener("pointermove", e => {
    if(!p.dragging) return;
    const dx = (e.clientX - p.startX) / scale;
    const dy = (e.clientY - p.startY) / scale;
    p.moved = Math.max(p.moved, Math.abs(dx)+Math.abs(dy));
    p.tx = p.baseX + dx;
    p.ty = p.baseY + dy;
  });
  el.addEventListener("pointerup", () => {
    if(!p.dragging) return;
    p.dragging = false;
    if(p.moved > 6){
      p.suppressClickUntil = performance.now() + 250;
    }
  });

    /* CLICK toggles HUDs (only if not dragged) */
  el.addEventListener("click", e => {
    if(e.target.closest(".flipBtn") || e.target.closest(".irBtn")) return;
    if(performance.now() < p.suppressClickUntil) return;

    // SOLO FRONTAL: no seleccionar/abrir HUD si estamos viendo el BACK
    if(card.classList.contains("flipped")) return;

    const willOpen = !el.classList.contains("hudOpen");
    closeAllHUD();

    // Glow de selecci√≥n
    if(selectedPiece && selectedPiece !== p) selectedPiece.el.classList.remove("selected");
    selectedPiece = p;
    el.classList.add("selected");

    if(willOpen){
      el.classList.add("flash");
      setTimeout(()=>el.classList.remove("flash"), 210);
      el.classList.add("hudOpen");
    }
  });

  return p;
}

/* LOAD MANIFEST */
function loadManifest(data){
  viewport.querySelectorAll(".piece").forEach(e => e.remove());
  pieces = [];
  zTop = 10;
  clearSelection();
  if(!data || !Array.isArray(data.cards)){
    alert("Manifest inv√°lido");
    return;
  }
  data.cards.forEach(createPiece);
  totalEl.textContent = "TOTAL: " + data.cards.length;
  stackCenter();
}

fetch("manifest/manifest.json", {cache:"no-store"}).then(r=>r.json()).then(loadManifest).catch(()=>{});

/* HEADER BUTTONS */
function stackCenter(){
  if(!pieces.length) return;
  closeAllHUD();
  clearSelection();

  const rect = stage.getBoundingClientRect();
  const cs = getComputedStyle(document.documentElement);
  const cardW = parseFloat(cs.getPropertyValue("--cardW")) || 175;
  const cardH = parseFloat(cs.getPropertyValue("--cardH")) || 246;

  const cx = (rect.width/2) - (cardW/2);
  const cy = (rect.height/2) - (cardH/2);

  pieces.forEach((p,i)=>{
    p.tx = cx;
    p.ty = cy;
    p.el.style.zIndex = i+1;
  });
  zTop = pieces.length + 5;

  // Home view: deck centered, slightly closer on mobile.
  scale = homeScale;
  panX = 0;
  panY = 0;
  updateView();
}

function dealRandom(){
  if(!pieces.length) return;
  closeAllHUD();
  clearSelection();
  closeAllHUD();
  const rect = stage.getBoundingClientRect();
  const maxX = Math.max(0, rect.width/scale - 175 - 12);
  const maxY = Math.max(0, rect.height/scale - 246 - 12);
  pieces.forEach(p=>{
    p.tx = 6 + Math.random()*maxX;
    p.ty = 6 + Math.random()*maxY;
    p.el.style.zIndex = ++zTop;
  });
}

function drawOne(){
  if(!pieces.length) return;
  closeAllHUD();
  clearSelection();
  closeAllHUD();
  const p = pieces[Math.floor(Math.random()*pieces.length)];
  p.el.style.zIndex = ++zTop;
  p.tx += 18;
  p.ty += 18;
  p.el.classList.add("flash");
  setTimeout(()=>p.el.classList.remove("flash"), 210);
}

btnDeck.addEventListener("click", stackCenter);
btnDeal.addEventListener("click", dealRandom);
btnDraw.addEventListener("click", drawOne);
btnMove.addEventListener("click", () => {
  moverOn = !moverOn;
  btnMove.classList.toggle("active", moverOn);
});
btnFrame.addEventListener("click", () => {
  closeAllHUD();
  clearSelection();
  scale = homeScale;
  panX = 0;
  panY = 0;
  updateView();
});

/* CLICK OUTSIDE closes HUDs */
document.addEventListener("pointerdown", (e)=>{
  if(e.target.closest("header")) return;
  if(e.target.closest(".piece")) return;
  closeAllHUD();
  clearSelection();
}, {capture:true});

/* PAN (clamped to BG) */
let panning=false, psx=0, psy=0, basePanX=0, basePanY=0, pid=null;
stage.addEventListener("pointerdown", e=>{
  if(e.target.closest(".piece")) return;
  panning=true;
  stage.classList.add("panning");
  psx = e.clientX; psy = e.clientY;
  basePanX = panX; basePanY = panY;
  pid = e.pointerId;
});
window.addEventListener("pointermove", e=>{
  if(!panning || e.pointerId!==pid) return;
  panX = basePanX + (e.clientX-psx);
  panY = basePanY + (e.clientY-psy);
  updateView();
});
window.addEventListener("pointerup", e=>{
  if(e.pointerId!==pid) return;
  panning=false;
  stage.classList.remove("panning");
});

/* ZOOM to cursor (locked minScale) */
stage.addEventListener("wheel", e=>{
  e.preventDefault();
  const rect = stage.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const worldX = (mx - panX) / scale;
  const worldY = (my - panY) / scale;

  const factor = e.deltaY < 0 ? 1.1 : 0.9;
  const newScale = Math.max(minScale, Math.min(maxScale, scale*factor));

  panX = mx - worldX * newScale;
  panY = my - worldY * newScale;
  scale = newScale;
  updateView();
},{passive:false});


/* PINCH ZOOM (mobile) */
const pointers = new Map(); // id -> {x,y}
let pinchStartDist = 0;
let pinchStartScale = 1;
let pinchWorldX = 0;
let pinchWorldY = 0;

function dist(a,b){
  const dx = a.x-b.x, dy = a.y-b.y;
  return Math.hypot(dx,dy);
}
function mid(a,b){
  return {x:(a.x+b.x)/2, y:(a.y+b.y)/2};
}

stage.addEventListener("pointerdown", e=>{
  // Ignore touches that start on cards to avoid confusing zoom/drag.
  if(e.target.closest(".piece")) return;
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
  // prevent default touch scrolling on mobile
  if(isMobile) e.preventDefault();

  // If the user puts a second finger down, initialize pinch immediately.
  if(pointers.size === 2){
    const [a,b] = Array.from(pointers.values());
    pinchStartDist = dist(a,b);
    pinchStartScale = scale;

    const m = mid(a,b);
    const rect = stage.getBoundingClientRect();
    const mx = m.x - rect.left;
    const my = m.y - rect.top;
    pinchWorldX = (mx - panX) / scale;
    pinchWorldY = (my - panY) / scale;
  }
},{passive:false});

stage.addEventListener("pointermove", e=>{
  if(!pointers.has(e.pointerId)) return;
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

  if(pointers.size === 2){
    // stop single-finger panning while pinching
    panning = false;
    stage.classList.remove("panning");

    const [a,b] = Array.from(pointers.values());
    const m = mid(a,b);
    const rect = stage.getBoundingClientRect();
    const mx = m.x - rect.left;
    const my = m.y - rect.top;

    const d = dist(a,b);
    // pinchStartDist is initialized on the second finger down.
    const factor = d / Math.max(1e-6, pinchStartDist);
    const newScale = Math.max(minScale, Math.min(maxScale, pinchStartScale * factor));

    panX = mx - pinchWorldX * newScale;
    panY = my - pinchWorldY * newScale;
    scale = newScale;
    updateView();
  }
},{passive:false});

window.addEventListener("pointerup", e=>{
  pointers.delete(e.pointerId);
  if(pointers.size < 2){
    pinchStartDist = 0;
  }
});
window.addEventListener("pointercancel", e=>{
  pointers.delete(e.pointerId);
  pinchStartDist = 0;
});

/* LOOP */
function tick(){
  const t = performance.now()*0.002;
  for(const p of pieces){
    if(moverOn && !p.dragging){
      p.tx += Math.sin(t + p.phase) * 0.35;
      p.ty += Math.cos(t*0.9 + p.phase*1.3) * 0.35;
    }
    p.x += (p.tx - p.x) * 0.15;
    p.y += (p.ty - p.y) * 0.15;
    p.el.style.transform = `translate(${p.x}px,${p.y}px)`;
  }
  requestAnimationFrame(tick);
}
tick();
updateBgMetrics();
updateView();

window.addEventListener("resize", ()=>{
  updateBgMetrics();
  updateView();
});

/* ===== v3-5: header micro-animations ===== */
document.querySelectorAll("header .hdrBtn .lbl").forEach(l => {
  l.setAttribute("data-txt", l.textContent.trim());
});

(function headerGlitchLoop(){
  const btns = Array.from(document.querySelectorAll("header .hdrBtn"));
  if(!btns.length) return;
  setInterval(() => {
    const b = btns[(Math.random()*btns.length)|0];
    b.classList.add("glitch");
    setTimeout(()=>b.classList.remove("glitch"), 260);
  }, 4200);
})();
/* ===== end v3-5 ===== */

</script>

</body>
</html>
